name: Update Linear Issue Status

on:
  pull_request:
    types: [closed]  # Only trigger on PR merge, not opened
    branches:
      - {{branches.main}}{{#branches.staging}}
      - {{branches.staging}}{{/branches.staging}}{{#branches.prod}}
      - {{branches.prod}}{{/branches.prod}}
  push:
    branches:
      - '**'           # All branches for feature work
      - '!{{branches.main}}'        # Exclude main (handled by PR merge){{#branches.staging}}
      - '!{{branches.staging}}'     # Exclude staging (handled by PR merge){{/branches.staging}}{{#branches.prod}}
      - '!{{branches.prod}}'        # Exclude prod (handled by PR merge){{/branches.prod}}
    paths-ignore:
      - '.github/**'   # Don't trigger on workflow changes
    # NOTE: Assumes {{branches.main}}{{#branches.prod}} and {{branches.prod}}{{/branches.prod}} are protected branches with PR-only merge policy.
    # Direct pushes to main/staging/prod should be prevented by branch protection rules.

jobs:
  update-linear:
    # Run on PR merged or push to feature branches
    if: |
      (github.event_name == 'pull_request' && github.event.action == 'closed' && github.event.pull_request.merged == true) ||
      (github.event_name == 'push')
    runs-on: ubuntu-latest

    permissions:
      contents: read
      pull-requests: read

    steps:
      - name: Validate LINEAR_API_KEY
        env:
          LINEAR_API_KEY: ${{ secrets.LINEAR_API_KEY }}
        run: |
          if [ -z "$LINEAR_API_KEY" ]; then
            echo "âŒ ERROR: LINEAR_API_KEY secret is not set"
            echo "Please add your Linear API key to GitHub repository secrets"
            exit 1
          fi
          echo "âœ… LINEAR_API_KEY is configured"

      - name: Extract Linear issue IDs
        id: extract-issues
        env:
          PR_BODY: ${{ github.event.pull_request.body }}
          COMMIT_MESSAGE: ${{ github.event.head_commit.message }}
        run: |
          ISSUE_IDS=""

          # Extract from PR body if this is a PR event
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            echo "ðŸ“‹ Extracting from PR body..."
            ISSUE_IDS=$(echo "$PR_BODY" | grep -ioE '(Fixes|Closes|Resolves|Partially[[:space:]]+fixes|Relates[[:space:]]+to|References)[[:space:]]+{{formats.issuePattern}}' | grep -ioE '{{formats.issuePattern}}' | tr '[:lower:]' '[:upper:]' | sort -u)
          fi

          # Extract from commit message if this is a push event
          if [ "${{ github.event_name }}" == "push" ]; then
            echo "ðŸ“‹ Extracting from commit message..."
            ISSUE_IDS=$(echo "$COMMIT_MESSAGE" | grep -ioE '{{formats.issuePattern}}' | tr '[:lower:]' '[:upper:]' | sort -u)
          fi

          # Convert to JSON array for easier processing
          if [ -n "$ISSUE_IDS" ]; then
            ISSUES_JSON=$(echo "$ISSUE_IDS" | jq -R -s -c 'split("\n") | map(select(length > 0))')
            echo "issues=$ISSUES_JSON" >> $GITHUB_OUTPUT
            echo "âœ… Found issues: $ISSUES_JSON"
          else
            echo "issues=[]" >> $GITHUB_OUTPUT
            echo "â„¹ï¸ No Linear issues found"
          fi

      - name: Determine target status
        id: target-status
        run: |
          EVENT_NAME="${{ github.event_name }}"
          ACTION="${{ github.event.action }}"
          BASE_BRANCH="${{ github.event.pull_request.base.ref }}"

          # Push event â†’ {{linear.statuses.inProgress}} (only if not already)
          if [ "$EVENT_NAME" == "push" ]; then
            echo "status_name={{linear.statuses.inProgress}}" >> $GITHUB_OUTPUT
            echo "check_current=true" >> $GITHUB_OUTPUT
            echo "âœ… Target status: {{linear.statuses.inProgress}} (will check current status first)"

          # PR merged to {{branches.main}} â†’ {{linear.statuses.review}}
          elif [ "$EVENT_NAME" == "pull_request" ] && [ "$ACTION" == "closed" ] && [ "$BASE_BRANCH" == "{{branches.main}}" ]; then
            echo "status_name={{linear.statuses.review}}" >> $GITHUB_OUTPUT
            echo "check_current=false" >> $GITHUB_OUTPUT
            echo "âœ… Setting status to: {{linear.statuses.review}} (merged to {{branches.main}})"
{{#branches.staging}}
          # PR merged to {{branches.staging}} â†’ {{linear.statuses.staging}}
          elif [ "$EVENT_NAME" == "pull_request" ] && [ "$ACTION" == "closed" ] && [ "$BASE_BRANCH" == "{{branches.staging}}" ]; then
            echo "status_name={{linear.statuses.staging}}" >> $GITHUB_OUTPUT
            echo "check_current=false" >> $GITHUB_OUTPUT
            echo "âœ… Setting status to: {{linear.statuses.staging}} (merged to {{branches.staging}})"
{{/branches.staging}}{{#branches.prod}}
          # PR merged to {{branches.prod}} â†’ {{linear.statuses.done}}
          elif [ "$EVENT_NAME" == "pull_request" ] && [ "$ACTION" == "closed" ] && [ "$BASE_BRANCH" == "{{branches.prod}}" ]; then
            echo "status_name={{linear.statuses.done}}" >> $GITHUB_OUTPUT
            echo "check_current=false" >> $GITHUB_OUTPUT
            echo "âœ… Setting status to: {{linear.statuses.done}} (merged to {{branches.prod}})"
{{/branches.prod}}
          else
            echo "status_name=" >> $GITHUB_OUTPUT
            echo "check_current=false" >> $GITHUB_OUTPUT
            echo "âš ï¸ Unknown event/branch combination - skipping status update"
          fi

      - name: Get workflow state ID
        id: get-state-id
        if: steps.extract-issues.outputs.issues != '[]' && steps.target-status.outputs.status_name != ''
        env:
          LINEAR_API_KEY: ${{ secrets.LINEAR_API_KEY }}
          TARGET_STATUS_NAME: ${{ steps.target-status.outputs.status_name }}
          LINEAR_TEAM_KEY: "{{linear.teamKey}}"
        run: |
          # Build GraphQL query to get workflow states with team info
          QUERY=$(jq -n --arg query 'query GetWorkflowStates { workflowStates { nodes { id name team { id key name } } } }' '{query: $query}')

          RESPONSE=$(curl -s -X POST https://api.linear.app/graphql \
            -H "Content-Type: application/json" \
            -H "Authorization: $LINEAR_API_KEY" \
            -d "$QUERY")

          # Check for API errors
          ERROR=$(echo "$RESPONSE" | jq -r '.errors[0].message // empty')
          if [ -n "$ERROR" ]; then
            echo "âŒ Linear API Error: $ERROR"
            exit 1
          fi

          # Extract state ID for target status name filtered by team
          STATE_ID=$(echo "$RESPONSE" | jq -r "[.data.workflowStates.nodes[] | select(.name == \"$TARGET_STATUS_NAME\" and .team.key == \"$LINEAR_TEAM_KEY\")] | first | .id")

          if [ -z "$STATE_ID" ] || [ "$STATE_ID" == "null" ]; then
            echo "âŒ ERROR: Could not find workflow state with name '$TARGET_STATUS_NAME' for team '$LINEAR_TEAM_KEY'"
            echo "Available states for team $LINEAR_TEAM_KEY:"
            echo "$RESPONSE" | jq -r ".data.workflowStates.nodes[] | select(.team.key == \"$LINEAR_TEAM_KEY\") | \"  - \(.name)\""
            exit 1
          fi

          echo "state_id=$STATE_ID" >> $GITHUB_OUTPUT
          echo "âœ… Using state ID: $STATE_ID for '$TARGET_STATUS_NAME' (Team: $LINEAR_TEAM_KEY)"

      - name: Update Linear issue status
        if: steps.get-state-id.outputs.state_id != ''
        env:
          LINEAR_API_KEY: ${{ secrets.LINEAR_API_KEY }}
          ISSUES: ${{ steps.extract-issues.outputs.issues }}
          STATE_ID: ${{ steps.get-state-id.outputs.state_id }}
          TARGET_STATUS_NAME: ${{ steps.target-status.outputs.status_name }}
          EVENT_NAME: ${{ github.event_name }}
          ACTION: ${{ github.event.action }}
          PR_URL: ${{ github.event.pull_request.html_url }}
          PR_TITLE: ${{ github.event.pull_request.title }}
          BASE_BRANCH: ${{ github.event.pull_request.base.ref }}
          COMMIT_SHA: ${{ github.sha }}
          COMMIT_MESSAGE: ${{ github.event.head_commit.message }}
          REPO_URL: ${{ github.event.repository.html_url }}
        run: |
          # Parse issues array
          ISSUE_IDS=$(echo "$ISSUES" | jq -r '.[]')

          for ISSUE_ID in $ISSUE_IDS; do
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "Processing issue: $ISSUE_ID"

            # Lookup issue by identifier ({{formats.issueExample}}) - extract number and query by number
            ISSUE_NUMBER=$(echo "$ISSUE_ID" | grep -oE '[0-9]+')

            LOOKUP_QUERY=$(jq -n \
              --arg number "$ISSUE_NUMBER" \
              '{query: "query LookupIssue($number: Float!) { issues(filter: { number: { eq: $number } }) { nodes { id identifier title state { name } assignee { id name email } } } }", variables: {number: ($number | tonumber)}}')

            ISSUE_RESPONSE=$(curl -s -X POST https://api.linear.app/graphql \
              -H "Content-Type: application/json" \
              -H "Authorization: $LINEAR_API_KEY" \
              -d "$LOOKUP_QUERY")

            # Check for errors
            ERROR=$(echo "$ISSUE_RESPONSE" | jq -r '.errors[0].message // empty')
            if [ -n "$ERROR" ]; then
              echo "âŒ API Error for $ISSUE_ID: $ERROR"
              continue
            fi

            # Extract issue UUID
            ISSUE_UUID=$(echo "$ISSUE_RESPONSE" | jq -r '.data.issues.nodes[0].id // empty')
            ISSUE_TITLE=$(echo "$ISSUE_RESPONSE" | jq -r '.data.issues.nodes[0].title // "Unknown"')
            CURRENT_STATE=$(echo "$ISSUE_RESPONSE" | jq -r '.data.issues.nodes[0].state.name // "Unknown"')

            if [ -z "$ISSUE_UUID" ] || [ "$ISSUE_UUID" == "null" ]; then
              echo "âŒ Could not find issue $ISSUE_ID - it may not exist or you don't have access"
              continue
            fi

            echo "ðŸ“‹ Issue: $ISSUE_TITLE"
            echo "ðŸ”„ Current state: $CURRENT_STATE"

            # Check if we should skip update (for push events to {{linear.statuses.inProgress}})
            # Uses case-insensitive comparison for robustness
            CHECK_CURRENT="${{ steps.target-status.outputs.check_current }}"
            if [ "$CHECK_CURRENT" == "true" ] && [ "${CURRENT_STATE,,}" == "${TARGET_STATUS_NAME,,}" ]; then
              echo "âœ… Status already '$TARGET_STATUS_NAME' - skipping update"
              continue
            fi

            echo "âž¡ï¸  Target state: $TARGET_STATUS_NAME"

            # Update issue status using properly escaped mutation
            UPDATE_MUTATION=$(jq -n \
              --arg id "$ISSUE_UUID" \
              --arg stateId "$STATE_ID" \
              '{query: "mutation UpdateIssue($id: String!, $stateId: String!) { issueUpdate(id: $id, input: { stateId: $stateId }) { success issue { identifier title state { name } } } }", variables: {id: $id, stateId: $stateId}}')

            UPDATE_RESPONSE=$(curl -s -X POST https://api.linear.app/graphql \
              -H "Content-Type: application/json" \
              -H "Authorization: $LINEAR_API_KEY" \
              -d "$UPDATE_MUTATION")

            # Check update success
            SUCCESS=$(echo "$UPDATE_RESPONSE" | jq -r '.data.issueUpdate.success // false')
            ERROR=$(echo "$UPDATE_RESPONSE" | jq -r '.errors[0].message // empty')

            if [ "$SUCCESS" == "true" ]; then
              echo "âœ… Successfully updated $ISSUE_ID to '$TARGET_STATUS_NAME'"
            else
              echo "âŒ Failed to update $ISSUE_ID"
              [ -n "$ERROR" ] && echo "   Error: $ERROR"
              continue
            fi

{{#assignees.enabled}}
            # Auto-assignment logic
            ASSIGNEE_ID=""
            ASSIGNEE_NAME=""

            # Determine assignee based on target status
            if [ "$TARGET_STATUS_NAME" == "{{linear.statuses.inProgress}}" ]; then
              ASSIGNEE_ID="{{assignees.onInProgress}}"
              ASSIGNEE_NAME="onInProgress"
            elif [ "$TARGET_STATUS_NAME" == "{{linear.statuses.review}}" ]; then
              ASSIGNEE_ID="{{assignees.onReview}}"
              ASSIGNEE_NAME="onReview"{{#branches.staging}}
            elif [ "$TARGET_STATUS_NAME" == "{{linear.statuses.staging}}" ]; then
              ASSIGNEE_ID="{{assignees.onStaging}}"
              ASSIGNEE_NAME="onStaging"{{/branches.staging}}{{#branches.prod}}
            elif [ "$TARGET_STATUS_NAME" == "{{linear.statuses.done}}" ]; then
              ASSIGNEE_ID="{{assignees.onDone}}"
              ASSIGNEE_NAME="onDone"{{/branches.prod}}
            fi

            # Perform assignment if configured
            if [ -n "$ASSIGNEE_ID" ] && [ "$ASSIGNEE_ID" != "null" ]; then
              echo "ðŸ‘¤ Auto-assignment configured for $ASSIGNEE_NAME"

{{#assignees.preserveOriginal}}
              # Check if issue already has an assignee
              CURRENT_ASSIGNEE=$(echo "$ISSUE_RESPONSE" | jq -r '.data.issues.nodes[0].assignee.id // empty')

              if [ -n "$CURRENT_ASSIGNEE" ] && [ "$CURRENT_ASSIGNEE" != "null" ]; then
                echo "   â„¹ï¸  Issue already assigned - preserving original assignee"
              else
{{/assignees.preserveOriginal}}
                # Update assignee
                ASSIGN_MUTATION=$(jq -n \
                  --arg id "$ISSUE_UUID" \
                  --arg assigneeId "$ASSIGNEE_ID" \
                  '{query: "mutation UpdateAssignee($id: String!, $assigneeId: String!) { issueUpdate(id: $id, input: { assigneeId: $assigneeId }) { success issue { identifier assignee { name email } } } }", variables: {id: $id, assigneeId: $assigneeId}}')

                ASSIGN_RESPONSE=$(curl -s -X POST https://api.linear.app/graphql \
                  -H "Content-Type: application/json" \
                  -H "Authorization: $LINEAR_API_KEY" \
                  -d "$ASSIGN_MUTATION")

                ASSIGN_SUCCESS=$(echo "$ASSIGN_RESPONSE" | jq -r '.data.issueUpdate.success // false')

                if [ "$ASSIGN_SUCCESS" == "true" ]; then
                  ASSIGNED_TO=$(echo "$ASSIGN_RESPONSE" | jq -r '.data.issueUpdate.issue.assignee.name // "Unknown"')
                  echo "   âœ… Assigned to: $ASSIGNED_TO"
                else
                  ASSIGN_ERROR=$(echo "$ASSIGN_RESPONSE" | jq -r '.errors[0].message // "Unknown error"')
                  echo "   âš ï¸  Failed to assign: $ASSIGN_ERROR"
                fi
{{#assignees.preserveOriginal}}
              fi
{{/assignees.preserveOriginal}}
            fi
{{/assignees.enabled}}

            # Create simple comment reference based on event type
            if [ "$EVENT_NAME" == "push" ]; then
              COMMIT_URL="$REPO_URL/commit/$COMMIT_SHA"
              COMMIT_TITLE=$(echo "$COMMIT_MESSAGE" | head -n 1)
              COMMENT_BODY="Commit pushed: [\`${COMMIT_SHA:0:7}\`]($COMMIT_URL) - $COMMIT_TITLE"
            elif [ "$EVENT_NAME" == "pull_request" ] && [ "$ACTION" == "closed" ] && [ "$BASE_BRANCH" == "{{branches.main}}" ]; then
              COMMENT_BODY="PR merged to \`{{branches.main}}\`: [$PR_TITLE]($PR_URL)"{{#branches.staging}}
            elif [ "$EVENT_NAME" == "pull_request" ] && [ "$ACTION" == "closed" ] && [ "$BASE_BRANCH" == "{{branches.staging}}" ]; then
              COMMENT_BODY="PR merged to \`{{branches.staging}}\`: [$PR_TITLE]($PR_URL)"{{/branches.staging}}{{#branches.prod}}
            elif [ "$EVENT_NAME" == "pull_request" ] && [ "$ACTION" == "closed" ] && [ "$BASE_BRANCH" == "{{branches.prod}}" ]; then
              COMMENT_BODY="PR merged to \`{{branches.prod}}\`: [$PR_TITLE]($PR_URL)"{{/branches.prod}}
            else
              COMMENT_BODY="Status updated to $TARGET_STATUS_NAME"
            fi

            COMMENT_MUTATION=$(jq -n \
              --arg issueId "$ISSUE_UUID" \
              --arg body "$COMMENT_BODY" \
              '{query: "mutation CreateComment($issueId: String!, $body: String!) { commentCreate(input: { issueId: $issueId, body: $body }) { success comment { id } } }", variables: {issueId: $issueId, body: $body}}')

            COMMENT_RESPONSE=$(curl -s -X POST https://api.linear.app/graphql \
              -H "Content-Type: application/json" \
              -H "Authorization: $LINEAR_API_KEY" \
              -d "$COMMENT_MUTATION")

            # Check comment success
            COMMENT_SUCCESS=$(echo "$COMMENT_RESPONSE" | jq -r '.data.commentCreate.success // false')

            if [ "$COMMENT_SUCCESS" == "true" ]; then
              echo "ðŸ’¬ Added comment to $ISSUE_ID"
            else
              COMMENT_ERROR=$(echo "$COMMENT_RESPONSE" | jq -r '.errors[0].message // "Unknown error"')
              echo "âš ï¸ Failed to add comment to $ISSUE_ID: $COMMENT_ERROR"
            fi

            # Rate limiting: small delay between iterations to avoid API throttling
            sleep 1
          done

          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "âœ… Completed processing all issues"

      - name: Summary
        if: always()
        run: |
          echo "### ðŸ”„ Linear Status Update Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Event**: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Action**: ${{ github.event.action || github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Target Status**: ${{ steps.target-status.outputs.status_name || 'N/A' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Issues Found**: ${{ steps.extract-issues.outputs.issues || '[]' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Workflow State ID**: ${{ steps.get-state-id.outputs.state_id || 'N/A' }}" >> $GITHUB_STEP_SUMMARY
